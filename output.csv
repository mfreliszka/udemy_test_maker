Question,Question Type,Answer Option 1,Explanation 1,Answer Option 2,Explanation 2,Answer Option 3,Explanation 3,Answer Option 4,Explanation 4,Answer Option 5,Explanation 5,Answer Option 6,Explanation 6,Correct Answers,Overall Explanation,Domain
"Blue/green deployments, Traffic-splitting deployments, Rolling deployments and Canary deployments. Which of them are supported by App Engine and which by GKE (pick 2)?",multi-select,"App Engine: Blue/green, Traffic-splitting, Rolling and Canary",,"GKE: Blue/green, Traffic-splitting, Rolling and Canary",,"GKE: Blue/green and Rolling automated, Traffic-splitting with tools",,"App Engine: Blue/green and Rolling automated, Traffic-splitting with tools",,,,,,"1,3,4","Correct answers: A, C, D App Engine has all the features of traffic splitting. GKE hase automated rolling updates but you have to create specific configurations for traffic splitting. Tools like Spinnaker make this task easier. See the referred material for a detailed procedure For any further detail: https://cloud.google.com/kubernetes-engine/docs/how-to/updating-apps https://cloud.google.com/solutions/automated-canary-analysis-kubernetes-engine-spinnaker https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic | https://cloud.google.com/kubernetes-engine/docs/how-to/updating-apps: https://cloud.google.com/kubernetes-engine/docs/how-to/updating-apps | https://cloud.google.com/solutions/automated-canary-analysis-kubernetes-engine-spinnaker: https://cloud.google.com/solutions/automated-canary-analysis-kubernetes-engine-spinnaker | https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic: https://cloud.google.com/appengine/docs/admin-api/migrating-splitting-traffic",
"For a project of yours, it is required a database with a non-rigid, high-performance schema that can easily manage Customers, Orders and Invoices relationships; in other words, you need to deal with hierarchically structured objects and you are looking for an economically convenient solution. In addition transactions, with serializable isolation enforcement are required. Which of the following products do you choose?",multiple-choice,Cloud Datastore,,Cloud Spanner,,Cloud Bigtable,,BigQuery,,Cloud SQL,,,,1,"Correct answer: A Datastore manages relationships between entities (records), in a hierarchically structured space similar to the directory structure of a file system. When you create an entity, you can optionally designate another entity as its parent; the new entity is a child of the parent entity. An entity without a parent is a root entity. A transaction is a set of Datastore operations on one or more entities in up to 25 entity groups. Each transaction is guaranteed to be atomic, which means that transactions are never partially applied. Either all of the operations in the transaction are applied, or none of them are applied. Regarding the other answer, for a flexible schema you need a noSQL Database. So, Datastore or Bigtable. All the others are SQL DBs. Datastore is the one that can manage transactions, even with serializable isolation enforcement. Bigtable don’t manage transactions. For any further detail: https://cloud.google.com/datastore/docs/concepts/entities#ancestor_paths https://cloud.google.com/datastore/docs/concepts/cloud-datastore-transactions | https://cloud.google.com/datastore/docs/concepts/entities#ancestor_paths: https://cloud.google.com/datastore/docs/concepts/entities#ancestor_paths | https://cloud.google.com/datastore/docs/concepts/cloud-datastore-transactions: https://cloud.google.com/datastore/docs/concepts/cloud-datastore-transactions",
How can you find out the problem origin and tune a slow SQL Statement in Cloud SQL or Cloud Spanner?,multiple-choice,Using Stackdriver Debugger,,Using Stackdriver Profiler,,Adding Secondary Indexes,,Examining Execution plans,,,,,,4,"Any SQL Database uses declarative statements that specify what data you want to retrieve. If you want to understand how it obtains the results, you should use look at execution plans. A query execution plan displays the cost associated with each step of the query. Using those costs, you can debug query performance issues and optimize your query. | Image: https://skillcertpro.com/wp-content/uploads/2020/08/a28.png | https://skillcertpro.com/wp-content/uploads/2020/08/a28.png | A and B are for procedural languages. C is wrong because it doesn’t address the problem; in case you may find out which index to add looking ad the execution plan. For any further detail: https://cloud.google.com/spanner/docs/sql-best-practices | https://cloud.google.com/spanner/docs/sql-best-practices: https://cloud.google.com/spanner/docs/sql-best-practices",
